package cluster

import (
	"time"

	"github.com/charter-se/structured/errors"
	"google.golang.org/grpc"
	yaml "gopkg.in/yaml.v2"
	"k8s.io/helm/pkg/helm"
	"k8s.io/helm/pkg/proto/hapi/chart"
)

type ReleaseMeta struct {
	Path             string //Location of Chartfile
	Name             string //Name of release, overrides autogenerated name if present
	Namespace        string
	ValueOverrides   []byte
	InstallDryRun    bool
	InstallReuseName bool
	InstallWait      bool
	InstallTimeout   time.Duration
	DryRun           bool
}

type DeleteMeta struct {
	Name      string
	Namespace string
}

type Chart = chart.Chart

type Release struct {
	Chart     *Chart
	Name      string
	Namespace string
}

func (s *Session) ListReleases() ([]*Release, error) {
	var res []*Release
	r, err := s.Helm.ListReleases()
	if err != nil {
		return nil, errors.Wrap(err, "failed to Helm.ListReleases()")
	}
	for _, v := range r.GetReleases() {
		rel := &Release{
			Chart:     v.GetChart(),
			Name:      v.Name,
			Namespace: v.Namespace,
		}
		res = append(res, rel)
	}
	return res, err
}

func (s *Session) InstallRelease(m *ReleaseMeta, chart []byte) (string, string, error) {
	res, err := s.Helm.InstallRelease(
		m.Path,
		m.Namespace,
		helm.ReleaseName(m.Name),
		helm.ValueOverrides(m.ValueOverrides),
		helm.InstallDryRun(m.DryRun),
		helm.InstallReuseName(m.InstallReuseName),
		helm.InstallWait(m.InstallWait),
		helm.InstallTimeout(int64(m.InstallTimeout.Seconds())),
	)
	if err != nil {
		return "", "", errors.Wrap(err, "failed install")
	}
	y, err := yaml.Marshal(res.Release.Manifest)
	if err != nil {
		return res.Release.Name, "", err
	}
	return res.Release.Name, string(y), err
}

func (s *Session) UpgradeRelease(m *ReleaseMeta) (string, string, error) {
	res, err := s.Helm.UpdateRelease(
		m.Name,
		m.Path,
		//	helm.UpgradeRecreate(true),
		//	helm.UpgradeForce(true),
		helm.UpdateValueOverrides(m.ValueOverrides),
	)
	y, err := yaml.Marshal(res.Release.Config)
	if err != nil {
		return res.Release.Name, "", err
	}
	return res.Release.Info.Description, string(y), err
}

func (s *Session) DeleteReleases(dm []*DeleteMeta) error {
	for _, v := range dm {
		if err := s.DeleteRelease(v); err != nil {
			return err
		}
	}
	return nil
}

func (s *Session) DeleteRelease(m *DeleteMeta) error {
	_, err := s.Helm.DeleteRelease(m.Name, helm.DeletePurge(true))
	if err != nil {
		return errors.New(grpc.ErrorDesc(err))
	}
	return nil
}
